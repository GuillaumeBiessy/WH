% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{WH_2d}
\alias{WH_2d}
\title{2D Whittaker-Henderson Smoothing}
\usage{
WH_2d(
  d,
  ec,
  lambda,
  criterion,
  method,
  max_dim = 200,
  p,
  q = c(2, 2),
  framework,
  y,
  wt,
  quiet = FALSE,
  ...
)
}
\arguments{
\item{d}{Matrix of observed events whose rows and columns should be named.
Required in case of maximum likelihood estimation}

\item{ec}{Matrix of central exposure. Required in case of maximum likelihood
estimation. The central exposure corresponds to the sum of the exposure
period over the insured population. An individual experiencing an event of
interest during the year will no longer be exposed afterward and the
exposure should be reduced accordingly.}

\item{lambda}{Smoothing parameter vector of size \code{2}. If missing, an
optimization procedure will be used to find the optimal smoothing
parameter. If provided, no optimal smoothing parameter search will take
place unless the \code{criterion} argument is also provided, in which case
\code{lambda} will be used as the starting parameter for the optimization
procedure.}

\item{criterion}{Criterion to be used for the selection of the optimal
smoothing parameter. Default is \code{"REML"} which stands for restricted
maximum likelihood. Other options include \code{"AIC"}, \code{"BIC"} and \code{"GCV"}.}

\item{method}{Method to be used to find the optimal smoothing parameter.
Default to \code{"fixed_lambda"} if \code{lambda} is supplied, meaning no
optimization is performed. Otherwise, default to \code{"perf"} which means the
performance iteration method is used. The alternative \code{"outer"} method is
guaranteed to converge but slower. Both those methods rely on the \code{optim}
function from package \code{stats}.}

\item{max_dim}{Number of parameters to be kept in the optimization problem.
Default is \code{200}. Values higher than \code{2000} may result in very high
computation times and memory usage.}

\item{p}{Optional vector of size \code{2}. Maximum number of eigenvectors to keep
on each dimension after performing the eigen decomposition of the
penalization matrix. If missing, will be automatically computed so that the
dimensions of (square) matrices involved in the optimization problem
remains lower that the \code{max_dim} argument}

\item{q}{Order of penalization vector of size \code{2}. Polynoms of degrees
\verb{(q[[1]] - 1,q[[2]] - 1)} are considered smooth and are therefore
unpenalized. Should be left to the default of \code{c(2,2)} for most practical
applications.}

\item{framework}{Default framework is \code{"ml"} which stands for maximum
likelihood unless the \code{y} argument is also provided, in which case an
\code{"reg"} or regression framework is used. The regression framework is an
approximate gaussian framework is used instead.}

\item{y}{Optional matrix of observations whose rows and columns should be
named. Used only in the regression framework and even in this case will be
automatically computed if the \code{d} and \code{ec} arguments are supplied. May be
useful when using Whittaker-Henderson smoothing outside of the survival
analysis framework.}

\item{wt}{Optional matrix of weights. As for the observation vector \code{y}, used
only in the regression framework and even in this case will be
automatically computed if the \code{d} argument is supplied. May be useful when
using Whittaker-Henderson smoothing outside of the survival analysis
framework.}

\item{quiet}{Should messages and warnings be displayed ? Default to \code{FALSE},
may be set to \code{TRUE} if numerous calls to this function are made.}

\item{...}{Additional parameters passed to the smoothing function called.}
}
\value{
An object of class \code{WH_2d} i.e. a list containing :
\itemize{
\item \code{d} The inputed matrix of observed events (if supplied as input)
\item \code{ec} The inputed matrix of central exposure (if supplied as input)
\item \code{y} The observation matrix (either supplied or computed as y = log(d) - log(ec))
\item \code{wt} The inputed matrix of weights (either supplied or computed as \code{d})
\item \code{y_hat} The matrix of fitted value
\item \code{std_y_hat} The matrix of standard deviation associated with the fitted value
\item \code{res} The matrix of model deviance residuals
\item \code{edf_obs} The matrix of effective degrees of freedom associated with each observation
\item \code{edf_par} The matrix of effective degrees of freedom associated with each eigenvector
\item \code{diagnosis} A data.frame with one line containing the effective degrees of freedom of the model, the deviance of the fit as well as the AIC, BIC, GCV and REML criteria
\item \code{Psi} The variance-covariance matrix associated with the fit, required for extrapolation.
\item \code{lambda} The vector of smoothing parameters used, either supplied. or computed.
\item \code{p} The number of components kept on each dimension after the rank reduction method is applied.
\item \code{q} The supplied vector of orders for the penalization.
}
}
\description{
#' Main package function to apply Whittaker-Henderson smoothing in a
bidimensional survival analysis framework. It takes as input a matrix of
observed events and a matrix of associated central exposure, both depending
on two covariates, and build a smooth version of the log-hazard rate.
Smoothing parameters may be supplied or automatically chosen according to a
specific criterion such as \code{"REML"} (the default), \code{"AIC"}, \code{"BIC"} or
\code{"GCV"}. Whittaker-Henderson may be applied in a full maximum likelihood
framework or an approximate gaussian framework. As Whittaker-Henderson
smoothing relies on full-rank smoothers, computation time and memory usage in
the bidimensional case may prove overwhelming and the function integrates a
rank-reduction procedure to avoid such issues.
}
\examples{
keep_age <- which(rowSums(portfolio_LTC$ec) > 1e2)
keep_duration <- which(colSums(portfolio_LTC$ec) > 1e2)

d  <- portfolio_LTC$d[keep_age, keep_duration]
ec <- portfolio_LTC$ec[keep_age, keep_duration]

y <- log(d / ec) # observation vector
y[d == 0] <- - 20
wt <- d

# Maximum likelihood
WH_2d(d, ec, lambda = c(1e2, 1e2))
WH_2d(d, ec) # performance iteration default method
\donttest{WH_2d(d, ec, method = "outer")} # slower but safer outer iteration method
WH_2d(d, ec, criterion = "GCV")
# alternative optimization criteria for smoothing parameter selection

# Regression
WH_2d(y = y, wt = wt, lambda = c(1e2, 1e2)) # regression framework is triggered when y is supplied
WH_2d(d, ec, framework = "reg", lambda = c(1e2, 1e2))
# setting framework = "reg" forces computation of y from d and ec

# Rank reduction
keep_age2 <- which(rowSums(portfolio_LTC$ec) > 0)
keep_duration2 <- which(colSums(portfolio_LTC$ec) > 0)
d  <- portfolio_LTC$d[keep_age2, keep_duration2]
ec <- portfolio_LTC$ec[keep_age2, keep_duration2]
prod(dim(d)) # problem dimension is 1,232 !
WH_2d(d, ec)
# rank-reduction is used to find an approximate solution using 200 parameters

}
